/**
 * Environment Variable Validator for Aixtiv CLI
 * 
 * This utility validates that all required environment variables are present
 * and properly formatted to ensure secure operation of the Aixtiv CLI within
 * the ASOOS architecture.
 * 
 * @module lib/utils/envValidator
 * @author Generated by Aixtiv Symphony OS
 * @version 1.0.0
 * @region us-west1
 */

const chalk = require('chalk');
const fs = require('fs');
const path = require('path');

// Check if agent-tracking is available for logging validation events
let logAgentAction;
try {
  const agentTracking = require('../agent-tracking');
  logAgentAction = agentTracking.logAgentAction;
} catch (error) {
  // Create a stub function if agent-tracking module is not available
  logAgentAction = (action, details) => {
    console.log(chalk.dim(`[No Agent Tracking] Action: ${action} | Details: ${JSON.stringify(details)}`));
    return Promise.resolve();
  };
}

// Error types and their colors
const ERROR_TYPES = {
  CRITICAL: {
    name: 'CRITICAL',
    color: 'red',
    exitCode: 1,
    symbol: '✖'
  },
  WARNING: {
    name: 'WARNING',
    color: 'yellow', 
    exitCode: 0,
    symbol: '⚠'
  },
  INFO: {
    name: 'INFO',
    color: 'blue',
    exitCode: 0,
    symbol: 'ℹ'
  },
  SUCCESS: {
    name: 'SUCCESS',
    color: 'green',
    exitCode: 0,
    symbol: '✓'
  }
};

/**
 * Environment variable schema definitions with validation rules
 */
const ENV_SCHEMA = {
  ANTHROPIC_API_KEY: {
    required: true,
    errorType: ERROR_TYPES.CRITICAL,
    description: 'Anthropic API key for Claude services',
    validator: (value) => {
      // Most API keys start with 'sk-' and are around 40+ characters
      return value && value.startsWith('sk-') && value.length >= 40;
    },
    errorMessage: 'Invalid format. Should start with "sk-" and be at least 40 characters long'
  },
  CLAUDE_API_ENDPOINT: {
    required: true,
    errorType: ERROR_TYPES.CRITICAL,
    description: 'Claude API endpoint URL',
    validator: (value) => {
      // Basic URL validation
      try {
        const url = new URL(value);
        return url.protocol === 'https:';
      } catch (e) {
        return false;
      }
    },
    errorMessage: 'Invalid URL format. Must be a valid HTTPS URL'
  },
  FIREBASE_CONFIG: {
    required: true,
    errorType: ERROR_TYPES.CRITICAL,
    description: 'Firebase configuration JSON',
    validator: (value) => {
      try {
        const config = JSON.parse(value);
        return (
          config &&
          typeof config === 'object' &&
          config.projectId &&
          config.apiKey
        );
      } catch (e) {
        return false;
      }
    },
    errorMessage: 'Invalid JSON format or missing required fields (projectId, apiKey)'
  },
  AGENT_TRACKING_DB: {
    required: false, // Not strictly required, but recommended
    errorType: ERROR_TYPES.WARNING,
    description: 'Agent tracking database path',
    validator: (value) => {
      // Just ensure it's a non-empty string
      return !!value;
    },
    errorMessage: 'Empty or missing value'
  },
  SALLYPORT_AUTH_TOKEN: {
    required: true,
    errorType: ERROR_TYPES.CRITICAL,
    description: 'SallyPort security authentication token',
    validator: (value) => {
      // Tokens should be at least 32 characters for security
      return value && value.length >= 32;
    },
    errorMessage: 'Invalid token format. Should be at least 32 characters for security'
  },
  // Cross-validation relationships
  // These will be checked after individual validations
  CROSS_VALIDATIONS: [
    {
      variables: ['FIREBASE_CONFIG', 'AGENT_TRACKING_DB'],
      validator: (values) => {
        // If we have both Firebase config and agent tracking, make sure they align
        if (!values.FIREBASE_CONFIG || !values.AGENT_TRACKING_DB) return true;
        
        try {
          const config = JSON.parse(values.FIREBASE_CONFIG);
          // Check if agent tracking DB path is within the expected GCP region
          if (config.projectId && values.AGENT_TRACKING_DB.includes('us-west1')) {
            return true;
          }
          return false;
        } catch (e) {
          return false;
        }
      },
      errorType: ERROR_TYPES.WARNING,
      errorMessage: 'AGENT_TRACKING_DB should be in the us-west1 region to match Firebase project'
    },
    {
      variables: ['ANTHROPIC_API_KEY', 'CLAUDE_API_ENDPOINT'],
      validator: (values) => {
        // If endpoint is Anthropic's, ensure we have a proper API key
        if (values.CLAUDE_API_ENDPOINT && values.CLAUDE_API_ENDPOINT.includes('api.anthropic.com')) {
          return values.ANTHROPIC_API_KEY && values.ANTHROPIC_API_KEY.startsWith('sk-');
        }
        return true;
      },
      errorType: ERROR_TYPES.CRITICAL,
      errorMessage: 'When using Anthropic\'s API, a valid API key must be provided'
    }
  ]
};

/**
 * Format and display a validation message
 * @param {string} varName - Name of the environment variable
 * @param {string} message - Message to display
 * @param {object} errorType - Error type object from ERROR_TYPES
 * @param {boolean} isValid - Whether validation passed
 */
function displayValidationMessage(varName, message, errorType, isValid) {
  const symbol = isValid ? ERROR_TYPES.SUCCESS.symbol : errorType.symbol;
  const color = isValid ? 'green' : errorType.color;
  
  console.log(
    chalk[color](`${symbol} ${errorType.name}`),
    chalk.white(`${varName}:`),
    chalk[color](message)
  );
}

/**
 * Validate a single environment variable
 * @param {string} varName - Name of the environment variable
 * @param {object} schema - Schema definition for this variable
 * @returns {object} Validation result { isValid, message, errorType }
 */
function validateEnvVar(varName, schema) {
  const value = process.env[varName];
  
  // Check if required but missing
  if (schema.required && !value) {
    return {
      isValid: false,
      message: 'Required but missing',
      errorType: schema.errorType
    };
  }
  
  // If not required and not present, it's valid but with a warning
  if (!schema.required && !value) {
    return {
      isValid: true,
      message: 'Not required but recommended',
      errorType: ERROR_TYPES.INFO
    };
  }
  
  // Validate format if validator exists
  if (value && schema.validator && !schema.validator(value)) {
    return {
      isValid: false,
      message: schema.errorMessage || 'Invalid format',
      errorType: schema.errorType
    };
  }
  
  return {
    isValid: true,
    message: 'Valid',
    errorType: ERROR_TYPES.SUCCESS
  };
}

/**
 * Perform cross-validation between related environment variables
 * @param {Array} validations - Array of cross-validation rule objects
 * @returns {Array} Array of validation results
 */
function performCrossValidations(validations) {
  const results = [];
  
  validations.forEach(validation => {
    const values = {};
    validation.variables.forEach(varName => {
      values[varName] = process.env[varName];
    });
    
    const isValid = validation.validator(values);
    
    if (!isValid) {
      results.push({
        isValid: false,
        variables: validation.variables,
        message: validation.errorMessage,
        errorType: validation.errorType
      });
    }
  });
  
  return results;
}

/**
 * Display cross-validation results
 * @param {Array} results - Cross-validation results
 */
function displayCrossValidationResults(results) {
  if (results.length === 0) {
    console.log(chalk.green('\n✓ All cross-validations passed'));
    return;
  }
  
  console.log(chalk.yellow('\nCross-validation issues:'));
  results.forEach(result => {
    const symbol = result.errorType.symbol;
    const varNames = result.variables.join(', ');
    
    console.log(
      chalk[result.errorType.color](`${symbol} ${result.errorType.name}`),
      chalk.white(`${varNames}:`),
      chalk[result.errorType.color](result.message)
    );
  });
}

/**
 * Validate all environment variables and return overall status
 * @param {boolean} displayOutput - Whether to display output to console
 * @returns {object} Validation results { isValid, criticalErrors, warnings }
 */
function validateEnvironment(displayOutput = true) {
  const results = {
    isValid: true,
    criticalErrors: 0,
    warnings: 0,
    details: {}
  };
  
  if (displayOutput) {
    console.log(chalk.cyan.bold('\n==== Aixtiv Environment Validator ===='));
    console.log(chalk.cyan('Running in region:'), chalk.white('us-west1'));
    console.log('');
  }
  
  // Validate each environment variable
  for (const [varName, schema] of Object.entries(ENV_SCHEMA)) {
    // Skip the cross-validations entry
    if (varName === 'CROSS_VALIDATIONS') continue;
    
    const result = validateEnvVar(varName, schema);
    results.details[varName] = result;
    
    if (!result.isValid) {
      if (result.errorType === ERROR_TYPES.CRITICAL) {
        results.criticalErrors++;
        results.isValid = false;
      } else if (result.errorType === ERROR_TYPES.WARNING) {
        results.warnings++;
      }
    }
    
    if (displayOutput) {
      displayValidationMessage(varName, result.message, result.errorType, result.isValid);
    }
  }
  
  // Perform cross-validations
  const crossValidationResults = performCrossValidations(ENV_SCHEMA.CROSS_VALIDATIONS);
  results.crossValidations = crossValidationResults;
  
  // Update overall status based on cross-validations
  crossValidationResults.forEach(result => {
    if (!result.isValid) {
      if (result.errorType === ERROR_TYPES.CRITICAL) {
        results.criticalErrors++;
        results.isValid = false;
      } else if (result.errorType === ERROR_TYPES.WARNING) {
        results.warnings++;
      }
    }
  });
  
  if (displayOutput) {
    displayCrossValidationResults(crossValidationResults);
    
    // Display summary
    console.log('\n--- Validation Summary ---');
    if (results.isValid && results.warnings === 0) {
      console.log(chalk.green('✓ All validations passed successfully'));
    } else if (results.isValid) {
      console.log(
        chalk.yellow(`⚠ Passed with ${results.warnings} warning${results.warnings !== 1 ? 's' : ''}`)
      );
    } else {
      console.log(
        chalk.red(`✖ Failed with ${results.criticalErrors} critical error${results.criticalErrors !== 1 ? 's' : ''}`) +
        (results.warnings ? chalk.yellow(` and ${results.warnings} warning${results.warnings !== 1 ? 's' : ''}`) : '')
      );
    }
  }
  
  // Log validation results to agent tracking system
  logAgentAction('environment_validation', {
    result: results.isValid ? 'passed' : 'failed',
    critical_errors: results.criticalErrors,
    warnings: results.warnings,
    timestamp: new Date().toISOString()
  });
  
  return results;
}

/**
 * CLI entry point
 */
function main() {
  const results = validateEnvironment(true);
  
  // Exit with appropriate code
  const exitCode = results.criticalErrors > 0 ? 1 : 0;
  process.exit(exitCode);
}

// Execute if run directly from CLI
if (require.main === module) {
  main();
}

// Export for programmatic use
module.exports = {
  validateEnvironment,
  ENV_SCHEMA,
  ERROR_TYPES
};
