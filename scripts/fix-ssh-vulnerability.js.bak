/**
 * SSH Vulnerability Fix for CVE-2024-45337
 *
 * This script fixes the critical vulnerability in golang.org/x/crypto's SSH implementation
 * by ensuring the PublicKeyCallback is used correctly to prevent authorization bypass.
 *
 * The vulnerability allows an attacker to send multiple public keys (A and B) and authenticate
 * with key A, while making the application use key B for authorization decisions.
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

const RED = '\x1b[31m';
const GREEN = '\x1b[32m';
const YELLOW = '\x1b[33m';
const RESET = '\x1b[0m';

const VULN_PATTERN = /ServerConfig\s*{[\s\S]*?PublicKeyCallback\s*:\s*func[\s\S]*?return[\s\S]*?}/g;
const FIXED_TEMPLATE = `ServerConfig{
  PublicKeyCallback: func(conn ssh.ConnMetadata, key ssh.PublicKey) (*ssh.Permissions, error) {
    // Validate the key
    if !isAuthorizedKey(key) {
      return nil, fmt.Errorf("unauthorized key")
    }
    
    // Store auth data in Permissions.Extensions
    return &ssh.Permissions{
      Extensions: map[string]string{
        "key-fingerprint": ssh.FingerprintSHA256(key),
        "user-id": getUserIDForKey(key),
      },
    }, nil
  },
}`;

function findGoFiles(dir) {
  const goFiles = [];

  function scanDir(currentDir) {
    try {
      const files = fs.readdirSync(currentDir);

      for (const file of files) {
        const filePath = path.join(currentDir, file);
        const stats = fs.statSync(filePath);

        if (stats.isDirectory() && file !== 'node_modules' && file !== '.git') {
          scanDir(filePath);
        } else if (stats.isFile() && path.extname(file) === '.go') {
          goFiles.push(filePath);
        }
      }
    } catch (err) {
      console.error(`Error scanning directory ${currentDir}: ${err.message}`);
    }
  }

  scanDir(dir);
  return goFiles;
}

function checkForVulnerability(filePath) {
  try {
    const content = fs.readFileSync(filePath, 'utf8');

    // Check if the file imports the vulnerable package
    if (!content.includes('golang.org/x/crypto/ssh')) {
      return { vulnerable: false };
    }

    // Look for ServerConfig with PublicKeyCallback
    const matches = content.match(VULN_PATTERN);
    if (!matches) {
      return { vulnerable: false };
    }

    // Check if any match is vulnerable
    for (const match of matches) {
      // If it doesn't store authentication data in Extensions
      if (!match.includes('Extensions:') && !match.includes('Extensions map[string]string')) {
        return { vulnerable: true, match };
      }
    }

    return { vulnerable: false };
  } catch (err) {
    console.error(`Error reading file ${filePath}: ${err.message}`);
    return { vulnerable: false, error: err.message };
  }
}

function fixVulnerability(filePath, vulnerableCode) {
  try {
    let content = fs.readFileSync(filePath, 'utf8');

    // Replace the vulnerable pattern with the fixed template
    // This is a simplified fix - real fixes need to be more specific to the codebase
    content = content.replace(vulnerableCode, FIXED_TEMPLATE);

    // Write the fixed content back
    fs.writeFileSync(filePath, content, 'utf8');

    return true;
  } catch (err) {
    console.error(`Error fixing file ${filePath}: ${err.message}`);
    return false;
  }
}

function updateDependency() {
  try {
    console.log(`${YELLOW}Updating golang.org/x/crypto dependency...${RESET}`);
    execSync('go get -u golang.org/x/crypto@v0.31.0', { stdio: 'inherit' });
    execSync('go mod tidy', { stdio: 'inherit' });
    return true;
  } catch (err) {
    console.error(`${RED}Error updating dependency: ${err.message}${RESET}`);
    return false;
  }
}

function main() {
  console.log('ðŸ”’ SSH Vulnerability Scanner and Fixer for CVE-2024-45337');
  console.log('Scanning for vulnerable code patterns...');

  // Get current directory
  const currentDir = process.cwd();
  console.log(`Scanning directory: ${currentDir}`);

  // Find all Go files
  const goFiles = findGoFiles(currentDir);
  console.log(`Found ${goFiles.length} Go files.`);

  // Check each file for vulnerability
  let vulnerableFiles = [];

  for (const file of goFiles) {
    const result = checkForVulnerability(file);
    if (result.vulnerable) {
      vulnerableFiles.push({ file, match: result.match });
      console.log(`${RED}Vulnerable code found in: ${file}${RESET}`);
    }
  }

  if (vulnerableFiles.length === 0) {
    console.log(`${GREEN}No vulnerable code patterns found!${RESET}`);
  } else {
    console.log(
      `\n${RED}Found ${vulnerableFiles.length} files with vulnerable code patterns.${RESET}`
    );
    console.log('Attempting to fix vulnerabilities...');

    // Fix each vulnerable file
    let fixedCount = 0;
    for (const { file, match } of vulnerableFiles) {
      console.log(`Fixing ${file}...`);
      const success = fixVulnerability(file, match);
      if (success) {
        fixedCount++;
        console.log(`${GREEN}Successfully fixed: ${file}${RESET}`);
      } else {
        console.log(`${RED}Failed to fix: ${file}${RESET}`);
      }
    }

    console.log(
      `\n${GREEN}Fixed ${fixedCount} out of ${vulnerableFiles.length} vulnerable files.${RESET}`
    );
  }

  // Update dependency
  const updated = updateDependency();
  if (updated) {
    console.log(`${GREEN}Successfully updated golang.org/x/crypto to v0.31.0${RESET}`);
  }

  console.log('\nðŸŽ‰ Vulnerability remediation complete.');
  console.log('Please rebuild your application and redeploy.');
}

// Run the main function
main();
